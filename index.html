<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>SunMoon Proxy</title>
  <link rel="stylesheet" href="assets/style.css">
</head>
<body>
  <div class="app">
    <nav class="nav">
      <a class="brand" href="index.html">
        <img src="assets/logo.png" alt="SunMoon logo">
        <div class="name">SunMoon Proxy</div>
      </a>
      <a href="index.html">üè† Home</a>
      <a href="games.html">üéÆ Games</a>
      <a href="browser.html">üåê Browser</a>
      <a href="info.html">‚ÑπÔ∏è Info</a>
      <a href="settings.html">‚öôÔ∏è Settings</a>
    </nav>

    <header class="header">
      <!-- header simplified; controls live in browser shell -->
    </header>

    <div class="main">
      <!-- Browser shell: tabs, controls, and iframe -->
      <div class="browser-shell">
        <div class="tabs" id="tabsBar">
          <!-- tabs inserted by JS -->
          <button id="newTabBtn" class="new-tab">+</button>
        </div>

        <div class="browser-controls">
          <div class="nav-buttons">
            <button id="backBtn">‚óÄ</button>
            <button id="forwardBtn">‚ñ∂</button>
            <button id="reloadBtn">‚ü≥</button>
          </div>
          <form id="navForm" onsubmit="onNavigate(event)" class="url-form">
            <input id="urlBar" type="search" placeholder="Search or enter a URL..." autocomplete="off">
            <button type="submit" class="cta">Go</button>
          </form>
        </div>

        <iframe id="browserFrame" class="browser-frame" src="about:blank" sandbox="allow-same-origin allow-scripts allow-forms allow-popups"></iframe>
      </div>
    </div>

    <!-- Side buttons for quick actions -->
    <div class="side left">
      <img src="assets/settings_button.png" alt="Settings" onclick="openLink('sm://settings')">
    </div>

    <div class="side right">
      <img src="assets/info_button.png" alt="Info" onclick="openLink('sm://info')">
      <img src="assets/games_button.png" alt="Games" onclick="openLink('sm://games')">
    </div>

  </div>

  <!-- Version popup -->
  <div id="versionPopup" class="version-popup">
    New version available ‚Äî <a id="versionLink" href="#" target="_blank">relaunch</a>
  </div>

  <script>
    // Version check: compare local version.txt with remote hosted version
    async function fetchLocalVersion(){
      try{
        const r = await fetch('version.txt', {cache: 'no-store'});
        const txt = await r.text();
        const js = JSON.parse(txt);
        return js.version;
      }catch(e){ console.warn('local version read failed', e); return null }
    }

    async function fetchRemoteVersion(){
      // TODO: replace this URL with your hosted version.json on GitHub Pages or raw.githubusercontent.com
      const remote = 'https://raw.githubusercontent.com/Mip3r/SunMoonProxy/main/version.txt';
      try{
        const r = await fetch(remote, {cache: 'no-store'});
        const txt = await r.text();
        const js = JSON.parse(txt);
        return js.version;
      }catch(e){ console.warn('remote version fetch failed', e); return null }
    }

    function showVersionPopup(link){
      const el = document.getElementById('versionPopup');
      const a = document.getElementById('versionLink');
      a.href = link;
      el.classList.add('show');
    }

    async function checkVersion(){
      const local = await fetchLocalVersion();
      const remote = await fetchRemoteVersion();
      if(!local || !remote) return;
      if(local !== remote){
        // open relaunch link to GitHub repo
        showVersionPopup('https://github.com/Mip3r/SunMoonProxy');
      }
    }


    // Browser tab management and navigation
    const PROXY_BASE = ''; // configure to your worker if available

    let tabs = [];
    let currentTabId = null;

    function createTab(url = 'about:blank', title = 'New Tab'){
      const id = Date.now() + Math.floor(Math.random()*1000);
      tabs.push({ id, url, title, history: [url], historyIndex: 0 });
      renderTabs();
      switchTab(id);
    }

    function renderTabs(){
      const bar = document.getElementById('tabsBar');
      // remove existing tab nodes (except new tab button)
      Array.from(bar.querySelectorAll('.tab')).forEach(n => n.remove());
      tabs.forEach(t => {
        const el = document.createElement('div');
        el.className = 'tab' + (t.id === currentTabId ? ' active' : '');
        el.dataset.id = t.id;
        el.textContent = t.title || t.url;
        el.onclick = () => switchTab(t.id);
        bar.insertBefore(el, document.getElementById('newTabBtn'));
      });
    }

    function switchTab(id){
      const tab = tabs.find(x => x.id === id);
      if(!tab) return;
      currentTabId = id;
      document.getElementById('browserFrame').src = tab.url;
      document.getElementById('urlBar').value = tab.url === 'about:blank' ? '' : tab.url;
      renderTabs();
    }

    function closeTab(id){
      const idx = tabs.findIndex(t => t.id === id);
      if(idx === -1) return;
      tabs.splice(idx,1);
      if(tabs.length === 0) createTab();
      else if(currentTabId === id) switchTab(tabs[Math.max(0, idx-1)].id);
      else renderTabs();
    }

    function navigateTo(url){
      if(!currentTabId) createTab(url);
      const tab = tabs.find(t => t.id === currentTabId);
      if(!tab) return;
      const target = /^https?:\/\//i.test(url) ? url : 'https://' + url;
      tab.history = tab.history.slice(0, tab.historyIndex + 1);
      tab.history.push(target);
      tab.historyIndex = tab.history.length - 1;
      tab.url = target;
      document.getElementById('browserFrame').src = (PROXY_BASE ? PROXY_BASE + encodeURIComponent(target) : target);
      document.getElementById('urlBar').value = target;
      renderTabs();
    }

    function goBack(){
      const tab = tabs.find(t => t.id === currentTabId);
      if(!tab || tab.historyIndex <= 0) return;
      tab.historyIndex--;
      tab.url = tab.history[tab.historyIndex];
      document.getElementById('browserFrame').src = (PROXY_BASE ? PROXY_BASE + encodeURIComponent(tab.url) : tab.url);
      document.getElementById('urlBar').value = tab.url;
    }

    function goForward(){
      const tab = tabs.find(t => t.id === currentTabId);
      if(!tab || tab.historyIndex >= tab.history.length - 1) return;
      tab.historyIndex++;
      tab.url = tab.history[tab.historyIndex];
      document.getElementById('browserFrame').src = (PROXY_BASE ? PROXY_BASE + encodeURIComponent(tab.url) : tab.url);
      document.getElementById('urlBar').value = tab.url;
    }

    function reloadFrame(){
      const f = document.getElementById('browserFrame');
      f.src = f.src;
    }

    // Kick off version check and create initial tab after page load
    window.addEventListener('load', () => {
      checkVersion();
      createTab('about:blank', 'New Tab');
      document.getElementById('newTabBtn').addEventListener('click', () => createTab());
      document.getElementById('backBtn').addEventListener('click', goBack);
      document.getElementById('forwardBtn').addEventListener('click', goForward);
      document.getElementById('reloadBtn').addEventListener('click', reloadFrame);
    });

    // Handle sm:// protocol navigation
    function openLink(url) {
      if (!url.startsWith('sm://')) return;
      
      const page = url.replace('sm://', '');
      switch(page) {
        case 'games':
          location.href = 'games.html';
          break;
        case 'info':
          location.href = 'info.html';
          break;
        case 'settings':
          location.href = 'settings.html';
          break;
        case 'browser':
          location.href = 'browser.html';
          break;
        default:
          console.warn('Unknown sm:// link:', url);
      }
    }

    // Client navigation / search helper (uses tabbed iframe)
    function isLikelyURL(input){
      return /^https?:\/\//i.test(input) || /\./.test(input);
    }
    function onNavigate(e){
      e.preventDefault();
      const val = document.getElementById('urlBar').value.trim();
      if(!val) return;
      if(isLikelyURL(val)){
        navigateTo(val);
      }else{
        // Treat as search query
        const q = encodeURIComponent(val);
        navigateTo('https://www.google.com/search?q=' + q);
      }
    }
  </script>
</body>
</html>
